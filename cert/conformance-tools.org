:PROPERTIES:
:ID:       20220124T185712.222187
:ROAM_REFS: https://docs.google.com/document/d/1SyBKxJvMbpWrHHco8MaelPscXq069gywE78sGrk0wvs/edit#
:END:
#+TITLE: Tools for the DRP Conformance Test Suite
#+filetags: :Project:
#+PROPERTY: header-args:shell :session *drp-conformance* :results drawer

* Introduction and Setup

These are simple utilities and test fixtures used to drive the [[id:20211116T134053.585822][DRP Conformance Test Suite]].

They're all as simple as can be and written against Python 3.9. Please use a modern Python, the tools here make heavy use of modern Python features like type hinting to provide somewhat "magical" serialization and deserialization of Data Rights Requests.

I recommend installing Python 3.9 in accordance with your operating system's best principles[fn:1], and then install [[https://python-poetry.org/docs/][Poetry]] following that documentation.

#+begin_src shell
poetry shell
#+end_src

#+results:
:results:
Creating virtualenv datarightsprotocol-SSQrMXUl-py3.9 in /home/rrix/.cache/pypoetry/virtualenvs
Spawning shell within /home/rrix/.cache/pypoetry/virtualenvs/datarightsprotocol-SSQrMXUl-py3.9
. /home/rrix/.cache/pypoetry/virtualenvs/datarightsprotocol-SSQrMXUl-py3.9/bin/activate
echo 'org_babel_sh_eoe'
(datarightsprotocol-SSQrMXUl-py3.9)
:end:

Alternately, a =shell.nix= is provided for users for the [[https://nixos.org/][Nix Packaging Manager]] which can be instantiated via [[https://nixos.wiki/wiki/Development_environment_with_nix-shell][Nix Shell]] =nix-shell=.

* =genjwts=: JWT generation script

[[file:./src/datarightsprotocol/tools/genjwts.py][tools/genjwts.py]] is a script to generate JWTs signed by a bundled certificate as if it came from a test Authorized Agent.

This will only generate them but not decode or verify existing JWTs. Use [[https://jwt.io][the JWT Debugger]] instead.

#+begin_src shell :results drawer :exports both
genjwts --help
#+end_src

#+results:
:results:
Usage: genjwts [OPTIONS]

  Small utility function to generate an IdentityPayload and serialize it.

Options:
  -s, --secret TEXT    JWT HS256 signing key
  -t, --template TEXT  JWT template to populate
  -o, --override TEXT  specify overrides to the JWT template in the form of
                       'claim=val'. can be specified repeatedly.
  -v, --verify TEXT    specify claims to mark as 'verified'.
  --help               Show this message and exit.
:end:

inside of [[file:./jwts][./jwts]] we'll find some JSON templates which can be used with this tool:

#+begin_src shell :exports both
genjwts -t jwts/simple.json
#+end_src

#+results:
:results:
Constructing claim.
Overriding template: []
Verifying claims: ()

Your JWT has arrived.
eyJ0eXAiOiJKV1QiLCJhbGciOiJIUzI1NiJ9.eyJpc3MiOiJwaXAtdGVzdC1zdWl0ZSIsImF1ZCI6InRoZS1waXAiLCJzdWIiOiJ0aGUtY29uc3VtZXIiLCJuYW1lIjoidGhlLWNvbnN1bWVyIiwicG93ZXJfb2ZfYXR0b3JuZXkiOm51bGwsImVtYWlsIjoidGVzdGNvbnN1bWVyQGNvbnN1bWVyLm9yZyIsInBob25lX251bWJlciI6IjEgNjAyIDU1NSAxMjEyIn0._CbiyDqnorHtPwl-Z81y9m6f3tuhKDzFXSVu2qoJK14
:end:

All "debug" messages are sent to =STDERR= so you can safely use this in a shell pipeline or get only the JWT output to your terminal like:

#+begin_src shell :exports both
genjwts -t jwts/simple.json 2>/dev/null
#+end_src

#+results:
:results:
eyJ0eXAiOiJKV1QiLCJhbGciOiJIUzI1NiJ9.eyJpc3MiOiJwaXAtdGVzdC1zdWl0ZSIsImF1ZCI6InRoZS1waXAiLCJzdWIiOiJ0aGUtY29uc3VtZXIiLCJuYW1lIjoidGhlLWNvbnN1bWVyIiwicG93ZXJfb2ZfYXR0b3JuZXkiOm51bGwsImVtYWlsIjoidGVzdGNvbnN1bWVyQGNvbnN1bWVyLm9yZyIsInBob25lX251bWJlciI6IjEgNjAyIDU1NSAxMjEyIn0._CbiyDqnorHtPwl-Z81y9m6f3tuhKDzFXSVu2qoJK14
:end:

claims can be overridden by passing any =--override= options:

#+begin_src shell :exports both
genjwts -t jwts/simple.json -o name="ryan rix" -o email="drp@rix.si" 
#+end_src

#+results:
:results:
Constructing claim.
Overriding template: [['name', 'ryan rix'], ['email', 'drp@rix.si']]
Verifying claims: ()

Your JWT has arrived.
eyJ0eXAiOiJKV1QiLCJhbGciOiJIUzI1NiJ9.eyJpc3MiOiJwaXAtdGVzdC1zdWl0ZSIsImF1ZCI6InRoZS1waXAiLCJzdWIiOiJ0aGUtY29uc3VtZXIiLCJuYW1lIjoicnlhbiByaXgiLCJwb3dlcl9vZl9hdHRvcm5leSI6bnVsbCwiZW1haWwiOiJkcnBAcml4LnNpIiwicGhvbmVfbnVtYmVyIjoiMSA2MDIgNTU1IDEyMTIifQ.Sh9iZhDBc-9SyoDRBv7cZvuzlhtsrVE9OGcHVRoI4TI
:end:

claims can be marked as verified by passing any number of =--verify= options:

#+begin_src shell :exports both
genjwts -t jwts/simple.json -v email
#+end_src

#+results:
:results:
Constructing claim.
Overriding template: []
Verifying claims: ('email',)

Your JWT has arrived.
eyJ0eXAiOiJKV1QiLCJhbGciOiJIUzI1NiJ9.eyJpc3MiOiJwaXAtdGVzdC1zdWl0ZSIsImF1ZCI6InRoZS1waXAiLCJzdWIiOiJ0aGUtY29uc3VtZXIiLCJuYW1lIjoidGhlLWNvbnN1bWVyIiwicG93ZXJfb2ZfYXR0b3JuZXkiOm51bGwsImVtYWlsX3ZlcmlmaWVkIjoidGVzdGNvbnN1bWVyQGNvbnN1bWVyLm9yZyIsInBob25lX251bWJlciI6IjEgNjAyIDU1NSAxMjEyIn0.RtaiT4cU83F4CDEU9WvgjWBxBTy9rzdy6Gh0c_q6WXw
:end:

** What about the secrets?

This thing basically only supports =HS256= signature-only JWTs in its current implementation, and loads the secret from an environment variable =JWT_SECRET=. So:

#+begin_src shell :exports both :results drawer
export JWT_SECRET=''; echo secret is $JWT_SECRET # default embedded in the code!
genjwts -t jwts/simple.json 2>/dev/null
export JWT_SECRET='thisisdifferent!'; echo secret is $JWT_SECRET
genjwts -t jwts/simple.json 2>/dev/null
#+end_src

#+results:
:results:
secret is
eyJ0eXAiOiJKV1QiLCJhbGciOiJIUzI1NiJ9.eyJpc3MiOiJwaXAtdGVzdC1zdWl0ZSIsImF1ZCI6InRoZS1waXAiLCJzdWIiOiJ0aGUtY29uc3VtZXIiLCJuYW1lIjoidGhlLWNvbnN1bWVyIiwicG93ZXJfb2ZfYXR0b3JuZXkiOm51bGwsImVtYWlsIjoidGVzdGNvbnN1bWVyQGNvbnN1bWVyLm9yZyIsInBob25lX251bWJlciI6IjEgNjAyIDU1NSAxMjEyIn0._CbiyDqnorHtPwl-Z81y9m6f3tuhKDzFXSVu2qoJK14
secret is thisisdifferent!
eyJ0eXAiOiJKV1QiLCJhbGciOiJIUzI1NiJ9.eyJpc3MiOiJwaXAtdGVzdC1zdWl0ZSIsImF1ZCI6InRoZS1waXAiLCJzdWIiOiJ0aGUtY29uc3VtZXIiLCJuYW1lIjoidGhlLWNvbnN1bWVyIiwicG93ZXJfb2ZfYXR0b3JuZXkiOm51bGwsImVtYWlsIjoidGVzdGNvbnN1bWVyQGNvbnN1bWVyLm9yZyIsInBob25lX251bWJlciI6IjEgNjAyIDU1NSAxMjEyIn0.xf9KcMqiUE1x_JramIup5SVtAwWHcu_2EPTiSTT-ByA
:end:

It will need to be extended to support referring to an x509 certificate or multiple to support testing JWT encryption, and the x509 signatures which are required to enclose the trust network of a DRP implementers' network.

*** NEXT develop an interface for configuring the JWT security algorithms

* =genreqs=: Rights Request generation script

[[file:./src/datarightsprotocol/tools/genreqs.py][tools/genreqs.py]] composes with the JWT generation script to create entire Data Rights Requests. Like the JWT generation script, =stderr= can be stuff in to =/dev/null= for cleaner output.

#+begin_src shell
genreqs --help
#+end_src

#+results:
:results:
Usage: genreqs [OPTIONS]

  Small utility function to generate a DataRightsRequest and serialize it.

Options:
  -t, --template FILENAME  DRR template to populate.
  -j, --jwt FILENAME       Generate a JWT using the specified template,
                           otherwise read a serialized JWT from stdin (&
                           probably out of genjwts.py)
  -o, --override TEXT      Specify overrides to DRR values. Values specified
                           as a list will be overwritten on first override,
                           then appended to after, if that makes sense.
  --help                   Show this message and exit.
:end:

In [[file:./reqs/][./reqs]] we'll find some files containing JSON templates for the base Data Rights Requests.

In its default invocation, it will attempt to read a JWT from =stdin= -- pass a =--jwt= argument to specify a default JSON template with the default =genjwts= invocation.

#+begin_src shell
genreqs -t reqs/donotsell.json -j jwts/simple.json 2>/dev/null
#+end_src

#+results:
:results:
{"meta": {"version": "0.4"}, "relationships": [], "regime": "ccpa", "exercise": ["sale:opt-out"], "identity": "eyJ0eXAiOiJKV1QiLCJhbGciOiJIUzI1NiJ9.eyJpc3MiOiJwaXAtdGVzdC1zdWl0ZSIsImF1ZCI6InRoZS1waXAiLCJzdWIiOiJ0aGUtY29uc3VtZXIiLCJuYW1lIjoidGhlLWNvbnN1bWVyIiwicG93ZXJfb2ZfYXR0b3JuZXkiOm51bGwsImVtYWlsIjoidGVzdGNvbnN1bWVyQGNvbnN1bWVyLm9yZyIsInBob25lX251bWJlciI6IjEgNjAyIDU1NSAxMjEyIn0._CbiyDqnorHtPwl-Z81y9m6f3tuhKDzFXSVu2qoJK14"}
:end:

To create customized JWTs, use the =stdin= invocation (note that each invocation needs its =stderr= stuffed!):

#+begin_src shell
genjwts -v email 2>/dev/null | genreqs -t reqs/donotsell.json 2>/dev/null
#+end_src

#+results:
:results:
{
  "meta": {
    "version": "0.4"
  },
  "relationships": [],
  "regime": "ccpa",
  "exercise": [
    "sale:opt-out"
  ],
  "identity": "eyJ0eXAiOiJKV1QiLCJhbGciOiJIUzI1NiJ9.eyJpc3MiOiJwaXAtdGVzdC1zdWl0ZSIsImF1ZCI6InRoZS1waXAiLCJzdWIiOiJ0aGUtY29uc3VtZXIiLCJuYW1lIjoidGhlLWNvbnN1bWVyIiwicG93ZXJfb2ZfYXR0b3JuZXkiOm51bGwsImVtYWlsX3ZlcmlmaWVkIjoidGVzdGNvbnN1bWVyQGNvbnN1bWVyLm9yZyIsInBob25lX251bWJlciI6IjEgNjAyIDU1NSAxMjEyIn0.RtaiT4cU83F4CDEU9WvgjWBxBTy9rzdy6Gh0c_q6WXw\n"
}
:end:

Overrides can be set in the =genreqs= script:

#+begin_src shell
genreqs -j jwts/simple.json -t reqs/donotsell.json -o regime=voluntary 2>/dev/null
#+end_src

#+results:
:results:
{"meta": {"version": "0.4"}, "relationships": [], "regime": ["voluntary"], "exercise": ["sale:opt-out"], "identity": "eyJ0eXAiOiJKV1QiLCJhbGciOiJIUzI1NiJ9.eyJpc3MiOiJwaXAtdGVzdC1zdWl0ZSIsImF1ZCI6InRoZS1waXAiLCJzdWIiOiJ0aGUtY29uc3VtZXIiLCJuYW1lIjoidGhlLWNvbnN1bWVyIiwicG93ZXJfb2ZfYXR0b3JuZXkiOm51bGwsImVtYWlsIjoidGVzdGNvbnN1bWVyQGNvbnN1bWVyLm9yZyIsInBob25lX251bWJlciI6IjEgNjAyIDU1NSAxMjEyIn0._CbiyDqnorHtPwl-Z81y9m6f3tuhKDzFXSVu2qoJK14"}
:end:

* INPROGRESS Test Suite's Request collection

each DRR will be used to validate the "happy path" protocol guardrails, each will be used to exercise 3-5 time to validate that the PIP workflow can move between the multiplicative of =rights action * valid end state= and maybe one or two constants like CCPA v. voluntary compliance regulatory regimes.

Each one will have a JWT that'll need to be composed with the above generation script...

* =openapi.yaml= and a Swagger server to submit to the PIP

the [[https://www.openapis.org/][OpenAPI]] specification is a machine-readable description schema for describing APIs on the web. We'll be using this with a tool called [[https://swagger.io/][Swagger]] which provides an web app that can submit requests to APIs based on that =openapi= spec. This combination will allow for the "DRP certifier" to submit DRRs copied out of static JSON files or construct their own with DRRs generated by the above tooling.

[[file:openapi.yaml]] provides a PIP-interface YAML specification. It can be used to submit DRP requests to a PIP instance and is foundational for the tests in the DRP [[file:conformance-tests.org][conformance tests]].

*Be sure to edit =openapi.yaml='s servers list to add your instance*

After running =poetry shell=, the command =swagger= will start this HTTP server.

#+begin_src shell
swagger --help
#+end_src

#+results:
:results:
Usage: swagger [OPTIONS]

  start the DRP swagger tool.

Options:
  -h, --host TEXT     the host IP to listen on, defaults to all IPs/interfaces
  -p, --port INTEGER  port to listen on
  --help              Show this message and exit.
:end:

changing the =DRP_OPENAPI= environment variable to point to another =openapi.yaml= or =swagger.json= file is the only other useful configuration element.[fn:2]

Running =swagger= will print the URL it is visible on in the terminal output, but by default it is [[http://0.0.0.0:8001/swagger][here on port 8001]].

* =statusserver= Status Callback Server
:PROPERTIES:
:ID:       20220209T183517.086963
:END:

Recall that the DRP specification defines a "[[https://github.com/rrix/data-rights-protocol/blob/main/data-rights-protocol.md#204-post-status_callback-data-rights-status-callback-endpoint][=status_callback=]]" which is to be implemented by the *Authorized Agent* so that the *Privacy Infrastructure Provider or Covered Business* can push status changes to the AA rather than force the AA to poll a server every hour or day.

To test this flow, though, we need a server which has two endpoints:

- an HTTP POST receiver which can be set as the callback server in the =/exercise= request, it does nothing but log the Data Rights Status to a local database with a 2-3 day retention policy applied to the data.
- =GET /status?request_id=FOO= which can be queried by the certifier to list all of the state transitions recorded for the given request ID.

In [[file:status_server.py][status_server.py]] there is a dead-simple FastAPI server in less than 100 lines of Python which will behave as a status callback server and persist DRP status updates to disk.

[nb: i know i should provide better/stronger guidance here, this will "boil up" to a setup doc at the top of this with a full set of recommendations perhaps getting it running in a Docker container which can be hosted or run locally ...]

Invoke it from the DRP git checkout: =uvicorn status_server:app= and browse to [[http://localhost:8000]].

Now, somehow, this needs to be hosted on the World Wide Web so that your PIP implementation can contact it. [[https://ngrok.com/][ngrok]] and [[https://developers.cloudflare.com/cloudflare-one/connections/connect-apps/install-and-setup][cloudflared tunnel]] are the best recommendations the author has for this at the moment, both offer free accounts, but you may consider hosting this somewhere.

*** NEXT provide better guidance on tunneling setup

just pick a tool, give installation guidance, free account setup, create a command which starts the tunnel tool, grabs the URL for you to put in DRRs

* INPROGRESS The [[id:20220209T171652.987733][Test Plan]] document

That is what this document is shaping up to be so far -- a set of Test Cases, the inputs that go in to them, and simple scripts which can be used to validate the request on any UNIX-like system with a handful of tools installed in it. (i suppose we could just ship this in a docker container too)

* NEXT A spreadsheet to track and record Test Plan results

In a "perfect world" we would all use Emacs Org-mode and this document could be the test-plan but *also* execute the test plan but *also* collect and bubble up the results within the document for reporting. But I'm not going to ask you to use an obscure markup language to work with this system.

Instead, you get a spreadsheet which can be used to collect the results of each test plan for review, and this will link back to the test plan document where appropriate.

This spreadsheet will be used to refine the database schema for a future automated test suite.

* Footnotes

[fn:1] I will note that the author has not verified that this works on macOS or Windows. There is an assumption within this document and the Test Suite that you will have access to a POSIX-style shell. I have no idea how =poetry shell= works in cmd.exe or powershell, I would highly recommend setting up a WSL2 system. My apologies.

[fn:2] Unfortunately it's not so simple to add a command line flag because of how the FastAPI uvicorn app is instantiated, we don't have access to the =click= command line flags..
